# [TLSv1.2](https://tools.ietf.org/html/rfc5246)

> 除了翻译，我找不到能读懂 rfc 的方法了

## 5. HMAC 和 伪随机数函数（Pseudorandom Function）

TLS record layer 用一个 keyed Message Authentication Code (MAC) 来保护报文的完整性。本文档中所定义的 cipher suites 所用的 MAC 叫 `HMAC`，是一个基于哈希函数的 MAC。当然，cipher suite 不是一定要基于 HMAC，完全可以使用其他方式实现的 MAC。

In addition, a construction is required to do expansion of secrets into blocks of data for the purpose of key generation or validation. 伪随机函数输入 a secret、a seed、an identifying label 之后会产生一个任意长度的输出。

本章节我们定义了一个基于 HMAC 的 PRF，本文档以及之前（TLSv1.2 协商之时）的文档中所定义的 cipher suite 都要用到这个 PRF（基于 `SHA-256`），新的 cipher suite **必须**明确指定一个 PRF，并且，**应该**使用基于 SHA-256，或者更高强度的哈希函数。

> PRF 对应的哈希函数要 >= SHA-256

首先，我们定义一个 data expansion 函数 —— `P_hash(secret, data)`，P_hash 会用一个哈希函数把 `secret` 和 `seed` 扩展到一个任意长度的输出里。

```python
P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + 
                       HMAC_hash(secret, A(2) + seed) + 
                       HMAC_hash(secret, A(3) + seed) + ...
```

> `+` 表示连接（concatenation）

`A()` 的定义：

```python
A(0) = seed
A(1) = HMAC_hash(secret, A(i-1))
```

为了生成所需长度的数据，`P_hash` 可以任意迭代下去。举个栗子，如果我们用 `P_SHA256` 生成一个长度为 80 字节的数据，它必须首先迭代三次（到 A(3)）生成 96 字节长度的数据，最后一次迭代所多出来的 16 个字节会被丢弃掉。96 减 16，正好是 80 个字节。

TLS 的 PRF 是通过把 `P_hash` 函数作用于 `secret` 创建的：

```c
PRF(secret, label, seed) = P_<hash>(secret, label + seed)
```

`label` 是一个 ASCII 字符串，作为哈希函数输入时必须保持 `label` 的原生格式，不能添加额外的东西（例如：长度字节或末尾空字符）。

例如，"slithy toves" 所对应的 bytes：

```
73 6C 69 74 68 79 20 74 6F 76 65 73
```

## 6. TLS Record 协议

TLS Record 协议是一个分层的协议。每一层的报文包含的字段有「长度」、「描述」和「内容」。

TLS Record 对将要被传输的报文之后会做如下处理：


    把数据切分成可控的区块 => 压缩数据（可选）=> 应用 MAC => 加密 => 传输

接收到的数据做如下处理：
    
    解码 => 验证 => 解压缩（可选）=> 重组 => 给上一层

本文档所描述的四种协议都会用到 record 协议。

* the handshake protocol
* the alert protocol
* the change cipher suite protocol
* the application data protocol

为了保证 TLS 协议的扩展性，record 协议也会支持其他的 record content type。新的 record content type 由 `IANA` 定义在 `the TLS Content Type Registry`，第 12 章节描述了此内容。

TLS 协议的具体实现禁止发送未在本文档中定义的 content type，除非通过某个协议扩展协商而来。如果过 TLS 的具体实现接收到了一个未知的 record type，那么它必须发送一个 `unexpected_message` 警告。

任何基于 TLS 所设计的协议必须谨慎处理所有可能的攻击。从实践角度来看，协议的设计者必须非常清楚 TLS 能够以及无法提供的安全属性，决不能延后处理。

需要特别注意的是，record 的类型和长度并没有加密。如果这个信息本身是敏感的，应用的设计者可能会希望采取额外的步骤（padding, cover traffic）来最小化信息泄露。

### 6.1. 连接状态（Connection States）

TLS 连接状态表示 TLS Record 协议的操作环境。它指明了压缩算法、加密算法和一个 MAC 算法。此外，这些算法的参数已经确定：the MAC key and the bulk encryption keys for the connection in both the read and the write directions。逻辑上来说，总是会呈现四种连接状态：当前的读写状态以及挂起的读写状态。所有的 record 都是在当前读写状态下被处理。挂起状态的安全参数可以通过 TLS
Handshake 协议来设置，`ChangeCipherSpec` 可以有选择地让任一挂起状态变为“当前”，
